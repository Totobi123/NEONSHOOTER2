<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Defender 1v1</title>
    <!-- Socket.io Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .hud-element { position: absolute; color: white; font-weight: bold; pointer-events: none; }
        #p1-health-bar { top: 20px; left: 20px; width: 200px; height: 20px; border: 2px solid #fff; border-radius: 10px; background: #444; }
        #p1-health-fill { height: 100%; width: 100%; background: #0f0; border-radius: 10px; transition: width 0.2s, background 0.2s; }
        #p1-label { top: 5px; left: 20px; font-size: 14px; color: cyan; }
        #p2-health-bar { top: 20px; right: 20px; width: 200px; height: 20px; border: 2px solid #fff; border-radius: 10px; background: #444; }
        #p2-health-fill { height: 100%; width: 100%; background: #0f0; border-radius: 10px; transition: width 0.2s, background 0.2s; }
        #p2-label { top: 5px; right: 20px; font-size: 14px; color: magenta; text-align: right; }
        #pause-btn { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: #ff6b00; border: 2px solid white; padding: 10px 20px; font-size: 16px; color: white; cursor: pointer; border-radius: 5px; pointer-events: auto; z-index: 100; }
        #pause-btn:hover { background: #ff8c00; }
        .menu-box { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); padding: 40px; border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto; box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); }
        h1 { color: #fff; margin: 0 0 20px 0; font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px cyan; }
        p { color: #ccc; font-size: 1.2rem; margin-bottom: 30px; }
        button { background: linear-gradient(45deg, #00f260, #0575e6); border: none; padding: 15px 40px; color: white; font-size: 1.5rem; border-radius: 50px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; font-weight: bold; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(5, 117, 230, 0.6); }
        .mode-btn { margin: 10px; padding: 12px 35px; font-size: 1.3rem; border-radius: 30px; border: none; cursor: pointer; font-weight: bold; background: linear-gradient(45deg, #f093fb, #f5576c); color: white; }
        .mode-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(245, 87, 108, 0.6); }
        input { padding: 10px; font-size: 16px; border-radius: 5px; border: none; width: 200px; text-align: center; }
        .slider { width: 200px; margin: 10px auto; }
        .weapon-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px auto; width: fit-content; }
        .weapon-card { background: rgba(0,255,255,0.2); border: 2px solid cyan; padding: 15px; border-radius: 10px; cursor: pointer; text-align: center; transition: all 0.2s; }
        .weapon-card:hover { background: rgba(0,255,255,0.4); transform: scale(1.05); }
        .weapon-card.selected { background: rgba(0,255,255,0.6); border-color: lime; }
        .weapon-card p { margin: 5px 0; font-size: 0.9rem; }
        .stats-display { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.7); padding: 10px 15px; border: 1px solid cyan; border-radius: 5px; font-size: 12px; color: #0f0; pointer-events: none; }
        .color-picker { display: flex; gap: 10px; justify-content: center; margin: 15px 0; flex-wrap: wrap; }
        .color-option { width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 2px solid white; }
        .theme-option { display: inline-block; margin: 5px; padding: 8px 15px; border: 2px solid white; border-radius: 5px; cursor: pointer; background: rgba(255,255,255,0.1); }
        .theme-option.selected { background: rgba(0,255,255,0.6); border-color: cyan; }
        #pause-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-layer">
    <div id="p1-label" class="hud-element">Player 1</div>
    <div id="p1-health-bar" class="hud-element"><div id="p1-health-fill"></div></div>
    <div id="p2-label" class="hud-element">Player 2</div>
    <div id="p2-health-bar" class="hud-element"><div id="p2-health-fill"></div></div>
    <button id="pause-btn">PAUSE (ESC)</button>
    
    <div id="start-modal" class="menu-box">
        <h1>Neon Defender</h1>
        <p>1v1 PvP - Click to Start</p>
        <button id="localModeBtn" class="mode-btn">LOCAL 1v1</button>
        <button id="onlineModeBtn" class="mode-btn">ONLINE 1v1</button>
        <p style="margin-top:20px; font-size:0.9rem;">P1: WASD to Move, Click or ENTER to Shoot | P2: Arrow Keys to Move, SHIFT to Shoot</p>
    </div>
    
    <div id="local-choice-modal" class="menu-box" style="display: none;">
        <h1>Local Mode</h1>
        <p>Choose Your Opponent:</p>
        <button id="vs-bot-btn" class="mode-btn">VS BOT</button>
        <button id="vs-player-btn" class="mode-btn">VS PLAYER</button>
        <button id="backToMainBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
    </div>
    
    <div id="difficulty-modal" class="menu-box" style="display: none;">
        <h1>Choose Bot Difficulty</h1>
        <p>Select difficulty:</p>
        <button id="easy-btn" class="mode-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049);">EASY</button>
        <button id="medium-btn" class="mode-btn" style="background: linear-gradient(45deg, #ff9800, #e68900);">MEDIUM</button>
        <button id="hard-btn" class="mode-btn" style="background: linear-gradient(45deg, #f44, #c00);">HARD</button>
        <button id="backToCHoiceBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
    </div>
    
    <div id="detection-modal" class="menu-box" style="display: none;">
        <h1>Detect Keyboards</h1>
        <p>Press keys on your keyboards to detect them...</p>
        <div style="margin-top: 20px; font-size: 1rem; color: #0f0;">
            <div id="keyboard-list" style="text-align: left; margin: 20px auto; width: 300px; max-height: 150px; overflow-y: auto; border: 1px solid #0f0; padding: 10px; border-radius: 5px;">
                <p style="color: #888;">Waiting for keyboard input...</p>
            </div>
        </div>
        <p id="detection-status" style="margin-top: 20px; font-size: 0.85rem; color: #ff9800;">Detected 0 keyboards</p>
        <button id="continueDetectionBtn" class="mode-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049); margin-top: 20px; display: none;">CONTINUE (Found 2+)</button>
        <button id="skipDetectionBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">USE DEFAULTS</button>
    </div>
    
    <div id="calibration-modal" class="menu-box" style="display: none;">
        <h1 id="calibration-title">Assign Keyboards</h1>
        <p id="calibration-text">Select which keyboard for Player 1:</p>
        <div style="margin-top: 20px; text-align: left; margin-left: 50px;">
            <div id="keyboard-selector" style="margin-bottom: 20px;"></div>
        </div>
        <div style="margin-top: 20px; font-size: 1rem; color: #0f0;">
            <p id="p1-keyboard-status">Keyboard: <span style="color: #888;">Select above</span></p>
            <p id="p1-mouse-status">Mouse: <span style="color: #888;">Click anywhere</span></p>
            <p id="p2-keyboard-status" style="margin-top: 15px; display: none;">Keyboard: <span style="color: #0f0;">✓ Auto-assigned</span></p>
            <p id="p2-mouse-status" style="display: none;">Mouse: <span style="color: #888;">Click anywhere</span></p>
        </div>
        <button id="skipCalibrationBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">USE DEFAULTS (WASD + Arrows)</button>
    </div>
    
    <div id="online-modal" class="menu-box" style="display: none;">
        <h1>Online 1v1</h1>
        <p>Connect with a Player:</p>
        <button id="randomMatchBtn" class="mode-btn">RANDOM MATCH</button>
        <button id="codeMatchBtn" class="mode-btn">ENTER CODE</button>
        <button id="backFromOnlineBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
        
        <div id="code-section" style="display: none; margin-top: 20px;">
            <p>Your Code:</p>
            <input type="text" id="codeInput" placeholder="Enter or create code" maxlength="5">
            <p style="margin-top: 15px; font-size: 0.9rem;">Share this code with a friend</p>
            <button id="codeConnectBtn" class="mode-btn" style="margin-top: 10px;">CONNECT</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="menu-box" style="display: none;">
        <h1 id="winner-text">Player 1 Wins!</h1>
        <p style="font-size: 1rem; margin: 20px 0;">Victory!</p>
        <button id="replayBtn" class="mode-btn" style="background: linear-gradient(45deg, #00d4ff, #0099ff);">REPLAY</button>
        <button id="homeBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 10px;">HOME</button>
    </div>
    
    <div id="pause-modal" class="menu-box">
        <h1>PAUSED</h1>
        <button id="resumeBtn" class="mode-btn">RESUME (ESC)</button>
        <button id="homeFromPauseBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444);">HOME</button>
    </div>
    
    <div id="matching-modal" class="menu-box" style="display: none;">
        <h1>Finding Match...</h1>
        <p id="matching-text">Connecting to a random player...</p>
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
            <button id="copyCodeBtn" class="mode-btn" style="background: linear-gradient(45deg, #00d4ff, #0099ff); display: none;">COPY CODE</button>
            <button id="cancelMatchBtn" class="mode-btn" style="background: linear-gradient(45deg, #f44, #c00);">CANCEL</button>
        </div>
    </div>
    
    <div id="weapon-selection-modal" class="menu-box" style="display: none;">
        <h1>Select Your Weapon</h1>
        <p>Pick your loadout:</p>
        <div class="weapon-grid" id="weaponGrid"></div>
        <button id="startGameWithWeaponBtn" class="mode-btn" style="background: linear-gradient(45deg, #00d4ff, #0099ff);">START</button>
    </div>
    
    <div id="settings-modal" class="menu-box" style="display: none;">
        <h1>Settings</h1>
        
        <div style="margin: 20px 0;">
            <h3 style="color: cyan; margin-bottom: 10px;">Volume</h3>
            <input type="range" id="volumeSlider" class="slider" min="0" max="100" value="50">
            <p style="font-size: 0.9rem;">Volume: <span id="volumeValue">50</span>%</p>
        </div>
        
        <div style="margin: 20px 0;">
            <h3 style="color: cyan; margin-bottom: 10px;">Color Theme</h3>
            <div class="color-picker">
                <div class="color-option theme-neon" style="background: #0ff;" title="CYAN"></div>
                <div class="color-option theme-sunset" style="background: #ff0000;" title="RED"></div>
                <div class="color-option theme-ocean" style="background: #0066ff;" title="BLUE"></div>
                <div class="color-option theme-forest" style="background: #00ff00;" title="GREEN"></div>
            </div>
            <p style="font-size: 0.8rem; color: #999; margin-top: 10px;">CYAN | RED | BLUE | GREEN</p>
        </div>
        
        <div style="margin: 20px 0;">
            <h3 style="color: cyan; margin-bottom: 10px;">Visual Effects</h3>
            <label style="color: #ccc; margin: 10px;"><input type="checkbox" id="screenShakeToggle" checked> Screen Shake on Hit</label><br>
            <label style="color: #ccc; margin: 10px;"><input type="checkbox" id="particleToggle" checked> Particle Effects</label><br>
            <label style="color: #ccc; margin: 10px;"><input type="checkbox" id="trailToggle" checked> Bullet Trails</label>
        </div>
        
        <button id="closeSettingsBtn" class="mode-btn">CLOSE</button>
    </div>
    
    <div id="stats-container" class="stats-display" style="display: none; pointer-events: none;">
        <div>P1 Kills: <span id="p1-kills">0</span></div>
        <div>P1 Damage: <span id="p1-damage">0</span></div>
        <div>P2 Kills: <span id="p2-kills">0</span></div>
        <div>P2 Damage: <span id="p2-damage">0</span></div>
    </div>
    
    <button id="settingsBtn" style="position: absolute; bottom: 20px; right: 20px; background: #666; border: 2px solid white; padding: 8px 15px; cursor: pointer; border-radius: 5px; pointer-events: auto; z-index: 50;">⚙ SETTINGS</button>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

let gameActive = false;
let gamePaused = false;
let gameMode = null; // 'local' or 'online'
let localMode = null; // 'bot' or 'player'
let botDifficulty = 'medium'; // 'easy', 'medium', 'hard'
let animationId;
let isPlayingBot = false;

// GAME SETTINGS AND STATS
let soundVolume = 0.5;
let screenShakeEnabled = true;
let particleEffectsEnabled = true;
let bulletTrailsEnabled = true;
let selectedWeapon = 0;
let selectedWeaponP1 = 0;
let selectedWeaponP2 = 0;
let screenShakeAmount = 0;
let screenShakeIntensity = 3;
let currentTheme = 'neon';
const themes = {
    'neon': { p1: '#0ff', p2: '#f0f' },
    'sunset': { p1: '#ff0000', p2: '#ff6600' },
    'ocean': { p1: '#0066ff', p2: '#00ccff' },
    'forest': { p1: '#00ff00', p2: '#66ff00' }
};

// GAME STATS
let p1Kills = 0, p1Damage = 0;
let p2Kills = 0, p2Damage = 0;

// PARTICLES AND EFFECTS
let particles = [];

// SOUND SYSTEM
class SoundGenerator {
    constructor() { 
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.contextResumed = false;
    }
    resumeContext() {
        if(!this.contextResumed && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
            this.contextResumed = true;
        }
    }
    playSound(frequency, duration, type = 'sine') {
        if(soundVolume === 0) return;
        try {
            this.resumeContext();
            const now = this.audioContext.currentTime;
            const osc = this.audioContext.createOscillator();
            const gain = this.audioContext.createGain();
            osc.connect(gain);
            gain.connect(this.audioContext.destination);
            osc.frequency.value = frequency;
            osc.type = type;
            gain.gain.setValueAtTime(soundVolume * 0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
            osc.start(now);
            osc.stop(now + duration);
        } catch(e) { console.log('Sound error:', e); }
    }
    shoot() { this.playSound(400, 0.1); }
    hit() { this.playSound(200, 0.15); }
    gameOver() { this.playSound(150, 0.3); }
}
let soundGen = new SoundGenerator();

// PARTICLE SYSTEM
class Particle {
    constructor(x, y, vx, vy, color, life = 20) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; 
        this.color = color; this.life = life; this.maxLife = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1;
        this.life--;
    }
    draw() {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

function createExplosion(x, y, color, count = 10) {
    if(!particleEffectsEnabled) return;
    for(let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 3 + Math.random() * 2;
        particles.push(new Particle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, color, 25));
    }
}

function applyScreenShake(intensity = 5) {
    if(!screenShakeEnabled) return;
    screenShakeAmount = intensity * 3;
}

// Control registration
let calibrationMode = false;
let detectionMode = false;
let calibrationStep = 0; // 0 = select P1 kbd, 1 = P1 mouse, 2 = P2 mouse
let p1RegisteredKeys = new Set();
let p1RegisteredMouseButton = null;
let p2RegisteredKeys = new Set();
let p2RegisteredMouseButton = null;
let useDefaultControls = false;
let detectingKeyboards = true;
let detectedKeyboards = {}; // {keyboardId: {id, lastKeyCode, keyCount, name}}
let nextKeyboardId = 0;
let p1SelectedKeyboardId = null;
let p2SelectedKeyboardId = null;
let keyboardDetectionTimeout = null;

const weapons = [
    { name: 'Pistol', bullets: 1, speed: 15, damage: 10, fireRate: 200 },
    { name: 'Shotgun', bullets: 6, speed: 12, damage: 15, spread: 0.3, fireRate: 500 },
    { name: 'Sniper', bullets: 1, speed: 25, damage: 50, fireRate: 1000 }
];

class Player { 
    constructor(x, y, radius, color, isP2 = false) { 
        this.x = x; this.y = y; this.radius = radius; this.color = color; 
        this.velocity = { x: 0, y: 0 }; this.speed = 5; this.health = 100;
        this.isP2 = isP2;
        this.currentWeaponIndex = 0;
        this.lastShotTime = 0;
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.closePath(); ctx.shadowBlur = 0; }
    update(keys) {
        // Online mode: ALWAYS use default controls
        if(currentRoomId || useDefaultControls) {
            if(this.isP2) {
                if(keys['ArrowUp']) this.y -= this.speed;
                if(keys['ArrowDown']) this.y += this.speed;
                if(keys['ArrowLeft']) this.x -= this.speed;
                if(keys['ArrowRight']) this.x += this.speed;
            } else {
                if(keys['KeyW']) this.y -= this.speed;
                if(keys['KeyS']) this.y += this.speed;
                if(keys['KeyA']) this.x -= this.speed;
                if(keys['KeyD']) this.x += this.speed;
            }
        } else {
            // Local mode with calibrated controls
            const registeredKeys = this.isP2 ? p2RegisteredKeys : p1RegisteredKeys;
            for(let k in keys) {
                if(registeredKeys.has(k) && keys[k]) {
                    if(k.includes('Up') || k.includes('W')) this.y -= this.speed;
                    if(k.includes('Down') || k.includes('S')) this.y += this.speed;
                    if(k.includes('Left') || k.includes('A')) this.x -= this.speed;
                    if(k.includes('Right') || k.includes('D')) this.x += this.speed;
                }
            }
        }
        
        if(this.x - this.radius < 0) this.x = this.radius;
        if(this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
        if(this.y - this.radius < 0) this.y = this.radius;
        if(this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
        this.draw();
    }
}

class Bot {
    constructor(x, y, radius, color, difficulty = 'medium') {
        this.x = x; this.y = y; this.radius = radius; this.color = color;
        this.velocity = { x: 0, y: 0 }; this.health = 100;
        this.difficulty = difficulty;
        this.speed = difficulty === 'easy' ? 2.5 : difficulty === 'medium' ? 4 : 5.5;
        this.fireRate = difficulty === 'easy' ? 800 : difficulty === 'medium' ? 500 : 300;
        this.lastShotTime = 0;
        this.currentWeaponIndex = 0;
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.closePath(); ctx.shadowBlur = 0; }
    update(player1) {
        const angle = Math.atan2(player1.y - this.y, player1.x - this.x);
        this.velocity = { x: Math.cos(angle) * this.speed, y: Math.sin(angle) * this.speed };
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        
        if(this.x - this.radius < 0) this.x = this.radius;
        if(this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
        if(this.y - this.radius < 0) this.y = this.radius;
        if(this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
        
        const now = Date.now();
        if(now - this.lastShotTime > this.fireRate) {
            this.lastShotTime = now;
            const weapon = weapons[this.currentWeaponIndex];
            const velocity = { x: Math.cos(angle) * weapon.speed, y: Math.sin(angle) * weapon.speed };
            projectiles.push(new Projectile(this.x, this.y, 5, this.color, velocity, weapon.damage, this));
        }
        this.draw();
    }
}

class Projectile { 
    constructor(x, y, radius, color, velocity, damage, owner) {
        this.x = x; this.y = y; this.radius = radius; this.color = color; 
        this.velocity = velocity; this.damage = damage; this.owner = owner;
        this.prevX = x; this.prevY = y;
    }
    draw() { 
        if(bulletTrailsEnabled) {
            ctx.strokeStyle = this.color;
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.prevX, this.prevY);
            ctx.lineTo(this.x, this.y);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.closePath(); 
    }
    update() { this.prevX = this.x; this.prevY = this.y; this.x += this.velocity.x; this.y += this.velocity.y; this.draw(); }
}

let player1 = new Player(canvas.width/4, canvas.height/2, 15, themes['neon'].p1, false);
let player2 = new Player(canvas.width * 3/4, canvas.height/2, 15, themes['neon'].p2, true);
let bot = null;
let projectiles = [];
const keys = {};
window.lastMouseX = canvas.width / 2;
window.lastMouseY = canvas.height / 2;

// ===== WEBSOCKET MULTIPLAYER =====
let socket = null;
let currentRoomId = null;
let opponentData = null;
let onlinePlayerId = null;
let currentMatchCode = null;

// Initialize WebSocket connection
function initializeSocket() {
    if(socket && socket.connected) return;
    
    socket = io();
    
    socket.on('connect', () => {
        console.log('Connected to server');
    });
    
    socket.on('room-created', (data) => {
        currentRoomId = data.code;
        currentMatchCode = data.code;
        onlinePlayerId = 1;  // Host is always Player 1
        console.log('Room created with code:', data.code, 'Player ID:', onlinePlayerId);
        document.getElementById('online-modal').style.display = 'none';
        document.getElementById('matching-modal').style.display = 'flex';
        document.getElementById('matching-text').innerText = 'Your Code: ' + data.code + '\n\nWaiting for opponent...\n(Share this code)';
        document.getElementById('copyCodeBtn').style.display = 'inline-block';
    });
    
    socket.on('game-start', (data) => {
        // Server confirms our player ID and room
        onlinePlayerId = data.playerId;
        currentRoomId = data.roomId;  // CRITICAL: Joiner needs this to sync!
        currentMatchCode = data.roomId;
        console.log('Game starting! Room:', data.roomId, 'Player ID:', onlinePlayerId);
        document.getElementById('matching-modal').style.display = 'none';
        document.getElementById('copyCodeBtn').style.display = 'none';  // Hide copy button when game starts
        startGame();
    });
    
    socket.on('opponent-update', (data) => {
        if(gameActive) {
            // Handle updates for both player 1 and player 2 depending on our role
            if(onlinePlayerId === 1) {
                // We are player 1, so updates are for player 2
                player2.x = data.x;
                player2.y = data.y;
                player2.health = data.health;
            } else {
                // We are player 2, so updates are for player 1
                player1.x = data.x;
                player1.y = data.y;
                player1.health = data.health;
            }
            updateHealthBars();
        }
    });
    
    socket.on('opponent-projectile', (projectile) => {
        // Handle incoming projectiles from opponent
        // CRITICAL: Owner is the OTHER player, not always player2!
        const projectileOwner = onlinePlayerId === 1 ? player2 : player1;
        const velocity = { x: projectile.vx, y: projectile.vy };
        // Use Projectile class so it renders with draw()
        projectiles.push(new Projectile(
            projectile.x,
            projectile.y,
            5, // radius
            projectileOwner.color,
            velocity,
            projectile.damage,
            projectileOwner
        ));
    });
    
    socket.on('opponent-disconnect', () => {
        alert('Opponent disconnected!');
        goHome();
    });
    
    socket.on('room-not-found', () => {
        document.getElementById('matching-modal').style.display = 'none';
        document.getElementById('online-modal').style.display = 'flex';
        document.getElementById('matching-text').innerText = 'Room not found! Code may be incorrect.';
    });
    
    socket.on('opponent-timeout', () => {
        // No opponent found after 2 minutes - return to menu
        document.getElementById('matching-modal').style.display = 'none';
        document.getElementById('online-modal').style.display = 'flex';
        document.getElementById('matching-text').innerText = 'No opponent found. Returning to menu...';
    });
    
    socket.on('disconnect', () => {
        console.log('Disconnected from server');
    });
}

// Create online room
function createOnlineRoom() {
    if(!socket) initializeSocket();
    
    if(!socket.connected) {
        // Queue the room creation for when socket connects
        setTimeout(() => createOnlineRoom(), 200);
        return;
    }
    socket.emit('create-room');
}

// Join online room
function joinOnlineRoom(code) {
    if(!socket) initializeSocket();
    
    if(!socket.connected) {
        // Queue the room join for when socket connects
        setTimeout(() => joinOnlineRoom(code), 200);
        return;
    }
    
    onlinePlayerId = 2;  // Joiner is always Player 2
    console.log('Joining room with code:', code, 'Player ID:', onlinePlayerId);
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('matching-modal').style.display = 'flex';
    document.getElementById('matching-text').innerText = 'Connecting to: ' + code + '\n\nWaiting...';
    document.getElementById('copyCodeBtn').style.display = 'none';  // Joiner doesn't see copy button
    
    socket.emit('join-room', code);
}

// Sync game state - send EVERY FRAME with both players' data
function syncGameStateOnline() {
    if(!currentRoomId || !gameActive || !socket) return;
    
    // Send the controlled player's data
    if(onlinePlayerId === 1) {
        socket.emit('player-update', {
            x: player1.x,
            y: player1.y,
            health: player1.health,
            playerId: 1
        });
    } else {
        socket.emit('player-update', {
            x: player2.x,
            y: player2.y,
            health: player2.health,
            playerId: 2
        });
    }
}

window.addEventListener('keydown', (e) => {
    if(detectionMode && detectingKeyboards) {
        // Detect keyboard by proximity - keys pressed close in time are from same keyboard
        const currentTime = Date.now();
        let assignedKeyboard = null;
        
        // Check if this key belongs to an existing keyboard (within 300ms of last key)
        for(let id in detectedKeyboards) {
            const kbd = detectedKeyboards[id];
            if(currentTime - kbd.lastKeyCode < 300) {
                assignedKeyboard = id;
                break;
            }
        }
        
        // If no matching keyboard, create new one
        if(assignedKeyboard === null) {
            assignedKeyboard = nextKeyboardId++;
            const chars = 'ABCDEFGH';
            detectedKeyboards[assignedKeyboard] = {
                id: assignedKeyboard,
                lastKeyCode: currentTime,
                keyCount: 1,
                name: 'Keyboard ' + chars[assignedKeyboard]
            };
        } else {
            detectedKeyboards[assignedKeyboard].lastKeyCode = currentTime;
            detectedKeyboards[assignedKeyboard].keyCount++;
        }
        
        updateKeyboardList();
        
        // Restart timeout
        clearTimeout(keyboardDetectionTimeout);
        keyboardDetectionTimeout = setTimeout(() => {
            if(Object.keys(detectedKeyboards).length >= 2) {
                proceedToCalibration();
            }
        }, 3000);
        
        return;
    }
    
    if(calibrationMode && calibrationStep < 2) {
        // Store keys for selected player
        if(p1SelectedKeyboardId !== null && calibrationStep === 0) {
            p1RegisteredKeys.add(e.code);
            document.getElementById('p1-keyboard-status').innerHTML = 'Keyboard: <span style="color: #0f0;">✓ Keys detected</span>';
            calibrationStep = 1;
        } else if(p2SelectedKeyboardId !== null && calibrationStep === 1) {
            p2RegisteredKeys.add(e.code);
            document.getElementById('p2-keyboard-status').innerHTML = 'Keyboard: <span style="color: #0f0;">✓ Keys detected</span>';
            calibrationStep = 2;
        }
    }
    
    // Player 1 shoot with ENTER key
    if(e.code === 'Enter') {
        if(!gameActive || gamePaused) return;
        
        // In online mode: only allow Player 1 (host) to shoot with Enter
        if(currentRoomId && onlinePlayerId !== 1) return;
        
        const now = Date.now();
        const weapon = weapons[player1.currentWeaponIndex];
        const fireRate = weapon.fireRate;
        if(now - player1.lastShotTime < fireRate) return;
        player1.lastShotTime = now;
        // Shoot towards opponent (Player 2 or Bot)
        const targetX = isPlayingBot ? bot.x : player2.x;
        const targetY = isPlayingBot ? bot.y : player2.y;
        const angle = Math.atan2(targetY - player1.y, targetX - player1.x);
        for(let i = 0; i < weapon.bullets; i++) {
            let spreadAngle = angle;
            if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
            const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
            const proj = new Projectile(player1.x, player1.y, 5, player1.color, velocity, weapon.damage, player1);
            projectiles.push(proj);
            soundGen.shoot();
            
            // Sync projectile to opponent if online
            if(socket && currentRoomId) {
                socket.emit('fire-projectile', {
                    x: proj.x,
                    y: proj.y,
                    vx: proj.velocity.x,
                    vy: proj.velocity.y,
                    damage: proj.damage
                });
            }
        }
        return;
    }
    
    // Handle SHIFT shooting for Player 2
    if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        if(!gameActive || gamePaused) return;
        
        // In online mode: only allow Player 2 to shoot with shift
        if(currentRoomId && onlinePlayerId !== 2) return;
        
        const now = Date.now();
        const weapon = weapons[player2.currentWeaponIndex];
        const fireRate = weapon.fireRate;
        if(now - player2.lastShotTime < fireRate) return;
        player2.lastShotTime = now;
        const tx = player1.x;
        const ty = player1.y;
        const angle = Math.atan2(ty - player2.y, tx - player2.x);
        for(let i = 0; i < weapon.bullets; i++) {
            let spreadAngle = angle;
            if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
            const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
            const proj = new Projectile(player2.x, player2.y, 5, player2.color, velocity, weapon.damage, player2);
            projectiles.push(proj);
            soundGen.shoot();
            
            // Sync projectile to opponent if online
            if(socket && currentRoomId) {
                socket.emit('fire-projectile', {
                    x: proj.x,
                    y: proj.y,
                    vx: proj.velocity.x,
                    vy: proj.velocity.y,
                    damage: proj.damage
                });
            }
        }
        return;
    }
    
    // CRITICAL FIX: Always populate keys array for movement
    keys[e.code] = true;
    if(e.code === 'Escape') togglePause();
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

window.addEventListener('mousemove', (event) => {
    window.lastMouseX = event.clientX;
    window.lastMouseY = event.clientY;
});

window.addEventListener('click', (event) => {
    if(calibrationMode && calibrationStep === 1) {
        p1RegisteredMouseButton = true;
        document.getElementById('p1-mouse-status').innerHTML = 'Mouse: <span style="color: #0f0;">✓ Registered</span>';
        calibrationStep = 2;
    } else if(calibrationMode && calibrationStep === 2) {
        p2RegisteredMouseButton = true;
        document.getElementById('p2-mouse-status').innerHTML = 'Mouse: <span style="color: #0f0;">✓ Registered</span>';
        setTimeout(completeCalibration, 500);
        return;
    }
    
    if(!gameActive || gamePaused) return;
    
    // In online mode: only allow Player 1 to shoot with click
    if(currentRoomId && onlinePlayerId !== 1) return;
    
    const now = Date.now();
    const weapon = weapons[player1.currentWeaponIndex];
    const fireRate = weapon.fireRate;
    if(now - player1.lastShotTime < fireRate) return;
    player1.lastShotTime = now;
    const angle = Math.atan2(event.clientY - player1.y, event.clientX - player1.x);
    for(let i = 0; i < weapon.bullets; i++) {
        let spreadAngle = angle;
        if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
        const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
        const proj = new Projectile(player1.x, player1.y, 5, player1.color, velocity, weapon.damage, player1);
        projectiles.push(proj);
        
        // Sync projectile to opponent if online
        if(socket && currentRoomId) {
            socket.emit('fire-projectile', {
                x: proj.x,
                y: proj.y,
                vx: proj.velocity.x,
                vy: proj.velocity.y,
                damage: proj.damage
            });
        }
    }
});

function animate() {
    if(!gameActive) return;
    animationId = requestAnimationFrame(animate);
    
    let offX = 0, offY = 0;
    if(screenShakeAmount > 0) {
        offX = (Math.random() - 0.5) * screenShakeAmount;
        offY = (Math.random() - 0.5) * screenShakeAmount;
        screenShakeAmount *= 0.85;
    }
    ctx.save();
    ctx.translate(offX, offY);
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(-offX, -offY, canvas.width, canvas.height);
    
    if(!gamePaused) {
        // Update player movement based on mode
        if(currentRoomId) {
            // Online mode: only move the controlled player
            if(onlinePlayerId === 1) {
                player1.update(keys);
                // Player 2 position comes from opponent updates
            } else {
                player2.update(keys);
                // Player 1 position comes from opponent updates
            }
            // Sync online game state every frame
            syncGameStateOnline();
        } else if(isPlayingBot) {
            // Bot mode: move player and bot
            player1.update(keys);
            bot.update(player1);
        } else {
            // Local 2-player mode: move both players
            player1.update(keys);
            player2.update(keys);
        }
        
        // Handle projectiles based on mode
        if(isPlayingBot) {
            const opponent = bot;
            projectiles.forEach((p, i) => {
                p.update();
                if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    return;
                }
                
                if(p.owner === player1) {
                    const dist = Math.hypot(p.x - opponent.x, p.y - opponent.y);
                    if(dist < p.radius + opponent.radius) {
                        opponent.health -= p.damage;
                        p1Damage += p.damage;
                        soundGen.hit();
                        createExplosion(opponent.x, opponent.y, opponent.color);
                        applyScreenShake(20);
                        projectiles.splice(i, 1);
                        updateHealthBars();
                        updateStats();
                        if(opponent.health <= 0) {
                            p1Kills++;
                            soundGen.gameOver();
                            endGame(player1);
                        }
                    }
                } else {
                    const dist = Math.hypot(p.x - player1.x, p.y - player1.y);
                    if(dist < p.radius + player1.radius) {
                        player1.health -= p.damage;
                        p2Damage += p.damage;
                        soundGen.hit();
                        createExplosion(player1.x, player1.y, player1.color);
                        applyScreenShake(20);
                        projectiles.splice(i, 1);
                        updateHealthBars();
                        updateStats();
                        if(player1.health <= 0) {
                            p2Kills++;
                            soundGen.gameOver();
                            endGame(opponent);
                        }
                    }
                }
            });
        } else if(currentRoomId) {
            // Online multiplayer - handle projectiles
            // Each client detects hits on THEIR OWN avatar and syncs their health
            projectiles.forEach((p, i) => {
                p.update();
                if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    return;
                }
                
                // Check if this projectile hits MY avatar (not opponent)
                const myAvatar = onlinePlayerId === 1 ? player1 : player2;
                const opponentAvatar = onlinePlayerId === 1 ? player2 : player1;
                
                // Only process hits on MY avatar (opponent's projectiles hitting me)
                if(p.owner === opponentAvatar) {
                    const dist = Math.hypot(p.x - myAvatar.x, p.y - myAvatar.y);
                    if(dist < p.radius + myAvatar.radius) {
                        myAvatar.health -= p.damage;
                        if(onlinePlayerId === 1) p1Damage += p.damage; else p2Damage += p.damage;
                        soundGen.hit();
                        createExplosion(myAvatar.x, myAvatar.y, myAvatar.color);
                        applyScreenShake(20);
                        projectiles.splice(i, 1);
                        updateHealthBars();
                        updateStats();
                        
                        if(myAvatar.health <= 0) {
                            if(onlinePlayerId === 1) p2Kills++; else p1Kills++;
                            soundGen.gameOver();
                            endGame(opponentAvatar);
                        }
                    }
                }
            });
        } else {
            // Local 2-player mode - handle projectiles
            projectiles.forEach((p, i) => {
                p.update();
                if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    return;
                }
                
                const checkPlayer = p.owner === player1 ? player2 : player1;
                const dist = Math.hypot(p.x - checkPlayer.x, p.y - checkPlayer.y);
                if(dist < p.radius + checkPlayer.radius) {
                    checkPlayer.health -= p.damage;
                    if(p.owner === player1) p1Damage += p.damage; else p2Damage += p.damage;
                    soundGen.hit();
                    createExplosion(checkPlayer.x, checkPlayer.y, checkPlayer.color);
                    applyScreenShake(20);
                    projectiles.splice(i, 1);
                    updateHealthBars();
                    updateStats();
                    
                    if(checkPlayer.health <= 0) {
                        if(p.owner === player1) p1Kills++; else p2Kills++;
                        soundGen.gameOver();
                        endGame(p.owner === player1 ? player1 : player2);
                    }
                }
            });
        }
    }
    
    // Draw all players and projectiles
    if(isPlayingBot) {
        player1.draw();
        bot.draw();
    } else {
        player1.draw();
        player2.draw();
    }
    projectiles.forEach(p => p.draw && p.draw());
    
    // Draw particles
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => { p.update(); p.draw(); });
    
    ctx.restore();
}


function updateHealthBars() {
    document.getElementById('p1-health-fill').style.width = Math.max(0, player1.health) + '%';
    const p1Percent = Math.max(0, player1.health);
    document.getElementById('p1-health-fill').style.background = p1Percent > 50 ? '#0f0' : p1Percent > 20 ? '#ff0' : '#f00';
    
    const p2Health = isPlayingBot ? (bot ? bot.health : 100) : player2.health;
    document.getElementById('p2-health-fill').style.width = Math.max(0, p2Health) + '%';
    const p2Percent = Math.max(0, p2Health);
    document.getElementById('p2-health-fill').style.background = p2Percent > 50 ? '#0f0' : p2Percent > 20 ? '#ff0' : '#f00';
}

function updateStats() {
    document.getElementById('p1-kills').innerText = p1Kills;
    document.getElementById('p1-damage').innerText = p1Damage;
    document.getElementById('p2-kills').innerText = p2Kills;
    document.getElementById('p2-damage').innerText = p2Damage;
}

function initWeaponSelection() {
    const grid = document.getElementById('weaponGrid');
    grid.innerHTML = '';
    weapons.forEach((w, idx) => {
        const card = document.createElement('div');
        card.className = 'weapon-card' + (selectedWeapon === idx ? ' selected' : '');
        card.innerHTML = `<strong>${w.name}</strong><p>DMG: ${w.damage}</p><p>ROF: ${w.fireRate}ms</p>`;
        card.onclick = () => { selectedWeapon = idx; initWeaponSelection(); };
        grid.appendChild(card);
    });
}

function startGame() {
    player1.health = 100;
    player1.x = canvas.width/4;
    player1.y = canvas.height/2;
    player1.lastShotTime = 0;
    projectiles = [];
    particles = [];
    p1Kills = 0; p1Damage = 0;
    p2Kills = 0; p2Damage = 0;
    updateStats();
    gameActive = true;
    gamePaused = false;
    document.getElementById('stats-container').style.display = 'block';
    
    // For offline modes: ALWAYS use default controls
    if(!currentRoomId) {
        useDefaultControls = true;
    }
    
    if(isPlayingBot) {
        bot = new Bot(canvas.width * 3/4, canvas.height/2, 15, themes[currentTheme].p2, botDifficulty);
        document.getElementById('p1-label').innerText = 'You';
        document.getElementById('p2-label').innerText = 'Bot (' + botDifficulty.toUpperCase() + ')';
    } else if(currentRoomId) {
        // Online mode - labels depend on which player we are
        player2.health = 100;
        player2.x = canvas.width * 3/4;
        player2.y = canvas.height/2;
        player2.lastShotTime = 0;
        
        if(onlinePlayerId === 1) {
            // We are Host (Player 1)
            document.getElementById('p1-label').innerText = 'You (Host)';
            document.getElementById('p2-label').innerText = 'Player 2';
        } else {
            // We are Joiner (Player 2)
            document.getElementById('p1-label').innerText = 'Player 1';
            document.getElementById('p2-label').innerText = 'You (Joiner)';
        }
    } else {
        // Local 2-player
        player2.health = 100;
        player2.lastShotTime = 0;
        player2.x = canvas.width * 3/4;
        player2.y = canvas.height/2;
        document.getElementById('p1-label').innerText = 'Player 1';
        document.getElementById('p2-label').innerText = 'Player 2';
    }
    
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('matching-modal').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'block';
    updateHealthBars();
    animate();
}

function endGame(winner) {
    gameActive = false;
    cancelAnimationFrame(animationId);
    if(currentRoomId) {
        if(socket) socket.emit('game-end', {});
        document.getElementById('winner-text').innerText = winner === player1 ? 'You Win!' : 'Opponent Wins!';
    } else if(isPlayingBot) {
        document.getElementById('winner-text').innerText = winner === player1 ? 'You Win!' : 'Bot Wins!';
    } else {
        document.getElementById('winner-text').innerText = winner === player1 ? 'Player 1 Wins!' : 'Player 2 Wins!';
    }
    document.getElementById('game-over-modal').style.display = 'flex';
    document.getElementById('pause-btn').style.display = 'none';
}

function togglePause() {
    if(!gameActive) return;
    gamePaused = !gamePaused;
    document.getElementById('pause-modal').style.display = gamePaused ? 'flex' : 'none';
}

function startDetection() {
    detectionMode = true;
    detectingKeyboards = true;
    detectedKeyboards = {};
    nextKeyboardId = 0;
    p1SelectedKeyboardId = null;
    p2SelectedKeyboardId = null;
    
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('detection-modal').style.display = 'flex';
    updateKeyboardList();
    
    // Stop detection after 10 seconds of inactivity
    clearTimeout(keyboardDetectionTimeout);
    keyboardDetectionTimeout = setTimeout(() => {
        if(Object.keys(detectedKeyboards).length >= 2) {
            proceedToCalibration();
        } else {
            updateDetectionStatus();
        }
    }, 10000);
}

function updateKeyboardList() {
    const list = document.getElementById('keyboard-list');
    if(Object.keys(detectedKeyboards).length === 0) {
        list.innerHTML = '<p style="color: #888;">Waiting for keyboard input...</p>';
        return;
    }
    
    let html = '';
    for(let id in detectedKeyboards) {
        const kbd = detectedKeyboards[id];
        html += `<p style="margin: 5px 0; color: #0f0;">▌ ${kbd.name} (${kbd.keyCount} keys)</p>`;
    }
    list.innerHTML = html;
    updateDetectionStatus();
}

function updateDetectionStatus() {
    const count = Object.keys(detectedKeyboards).length;
    const status = document.getElementById('detection-status');
    const btn = document.getElementById('continueDetectionBtn');
    
    status.innerText = `Detected ${count} keyboard${count !== 1 ? 's' : ''}`;
    if(count >= 2) {
        btn.style.display = 'block';
        status.style.color = '#0f0';
    } else {
        btn.style.display = 'none';
        status.style.color = '#ff9800';
    }
}

function proceedToCalibration() {
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    
    if(Object.keys(detectedKeyboards).length < 2) {
        alert('Only 1 keyboard detected. Click USE DEFAULTS to continue with keyboard 1.');
        return;
    }
    
    document.getElementById('detection-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'flex';
    buildKeyboardSelector();
}

function buildKeyboardSelector() {
    const selector = document.getElementById('keyboard-selector');
    let html = '';
    for(let id in detectedKeyboards) {
        const kbd = detectedKeyboards[id];
        html += `<label style="display: block; margin: 10px 0; cursor: pointer;">
                    <input type="radio" name="p1-keyboard" value="${id}" style="cursor: pointer;"> ${kbd.name}
                 </label>`;
    }
    selector.innerHTML = html;
    
    // Add change listener
    document.querySelectorAll('input[name="p1-keyboard"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            p1SelectedKeyboardId = e.target.value;
            document.getElementById('p1-keyboard-status').innerHTML = `Keyboard: <span style="color: #0f0;">✓ ${detectedKeyboards[p1SelectedKeyboardId].name}</span>`;
            
            // Auto-assign other keyboard to P2
            for(let id in detectedKeyboards) {
                if(id !== p1SelectedKeyboardId) {
                    p2SelectedKeyboardId = id;
                    break;
                }
            }
            if(p2SelectedKeyboardId) {
                document.getElementById('p2-keyboard-status').innerHTML = `Keyboard: <span style="color: #0f0;">✓ ${detectedKeyboards[p2SelectedKeyboardId].name}</span>`;
            }
        });
    });
}

function startCalibration() {
    startDetection();
}

function completeCalibration() {
    calibrationMode = false;
    detectionMode = false;
    isPlayingBot = false;
    startGame();
}

function goHome() {
    gameActive = false;
    gamePaused = false;
    calibrationMode = false;
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    if(currentRoomId) {
        if(socket) socket.emit('game-end', {});
        currentRoomId = null;
    }
    cancelAnimationFrame(animationId);
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('detection-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'none';
    document.getElementById('matching-modal').style.display = 'none';
    document.getElementById('game-over-modal').style.display = 'none';
    document.getElementById('pause-modal').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function replayGame() {
    // Reset game state for replay
    gameActive = false;
    gamePaused = false;
    projectiles = [];
    player1.health = 100;
    player2.health = 100;
    if(bot) bot.health = 100;
    
    // Hide game over modal and reset
    document.getElementById('game-over-modal').style.display = 'none';
    
    // Restart game based on current mode
    if(isPlayingBot) {
        // Replay bot mode with same difficulty
        startGame();
    } else if(currentRoomId) {
        // Replay online mode - restart the game
        startGame();
    } else {
        // Replay local 2-player mode
        startGame();
    }
}

// Event Listeners
document.getElementById('localModeBtn').addEventListener('click', () => {
    gameMode = 'local';
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'flex';
});

document.getElementById('vs-bot-btn').addEventListener('click', () => {
    isPlayingBot = true;
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'flex';
});

document.getElementById('vs-player-btn').addEventListener('click', () => {
    startCalibration();
});

document.getElementById('easy-btn').addEventListener('click', () => {
    botDifficulty = 'easy';
    startGame();
});

document.getElementById('medium-btn').addEventListener('click', () => {
    botDifficulty = 'medium';
    startGame();
});

document.getElementById('hard-btn').addEventListener('click', () => {
    botDifficulty = 'hard';
    startGame();
});

document.getElementById('backToMainBtn').addEventListener('click', () => {
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('start-modal').style.display = 'flex';
});

document.getElementById('backToCHoiceBtn').addEventListener('click', () => {
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'flex';
});

document.getElementById('onlineModeBtn').addEventListener('click', () => {
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'flex';
});

document.getElementById('randomMatchBtn').addEventListener('click', () => {
    initializeSocket();
    createOnlineRoom();
});

document.getElementById('codeMatchBtn').addEventListener('click', () => {
    document.getElementById('code-section').style.display = 'block';
    document.getElementById('codeInput').value = '';
    document.getElementById('codeInput').focus();
});

document.getElementById('codeConnectBtn').addEventListener('click', () => {
    const code = document.getElementById('codeInput').value.toUpperCase();
    if(code.length < 3) { alert('Code must be at least 3 characters'); return; }
    initializeSocket();
    joinOnlineRoom(code);
});

document.getElementById('backFromOnlineBtn').addEventListener('click', () => {
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('code-section').style.display = 'none';
});

document.getElementById('copyCodeBtn').addEventListener('click', () => {
    if(currentMatchCode) {
        // Copy only the 5-character code
        const codeToShare = currentMatchCode.substring(0, 5);
        navigator.clipboard.writeText(codeToShare).then(() => {
            const btn = document.getElementById('copyCodeBtn');
            const origText = btn.innerText;
            btn.innerText = 'COPIED!';
            setTimeout(() => { btn.innerText = origText; }, 2000);
        });
    }
});

document.getElementById('cancelMatchBtn').addEventListener('click', () => {
    if(currentRoomId && socket) socket.emit('game-end', {});
    currentRoomId = null;
    currentMatchCode = null;
    document.getElementById('matching-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'flex';
    document.getElementById('code-section').style.display = 'none';
    document.getElementById('copyCodeBtn').style.display = 'none';
});

document.getElementById('skipDetectionBtn').addEventListener('click', () => {
    useDefaultControls = true;
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    isPlayingBot = false;
    document.getElementById('detection-modal').style.display = 'none';
    startGame();
});

document.getElementById('continueDetectionBtn').addEventListener('click', proceedToCalibration);

document.getElementById('skipCalibrationBtn').addEventListener('click', () => {
    useDefaultControls = true;
    calibrationMode = false;
    detectionMode = false;
    isPlayingBot = false;
    document.getElementById('calibration-modal').style.display = 'none';
    startGame();
});

document.getElementById('replayBtn').addEventListener('click', replayGame);
document.getElementById('homeBtn').addEventListener('click', goHome);
document.getElementById('homeFromPauseBtn').addEventListener('click', goHome);
document.getElementById('resumeBtn').addEventListener('click', togglePause);

// SETTINGS AND FEATURES EVENT LISTENERS
document.getElementById('settingsBtn').addEventListener('click', () => {
    document.getElementById('settings-modal').style.display = 'flex';
});

document.getElementById('closeSettingsBtn').addEventListener('click', () => {
    document.getElementById('settings-modal').style.display = 'none';
});

document.getElementById('volumeSlider').addEventListener('input', (e) => {
    soundVolume = e.target.value / 100;
    document.getElementById('volumeValue').innerText = e.target.value;
});

document.querySelectorAll('.color-option').forEach(opt => {
    opt.addEventListener('click', (e) => {
        let themeName = null;
        for(let cls of e.target.classList) {
            if(cls.startsWith('theme-')) {
                themeName = cls.replace('theme-', '');
                break;
            }
        }
        if(themeName && themes[themeName]) {
            currentTheme = themeName;
            player1.color = themes[themeName].p1;
            player2.color = themes[themeName].p2;
            if(bot) bot.color = themes[themeName].p2;
            document.querySelectorAll('.color-option').forEach(o => o.style.border = '2px solid #666');
            e.target.style.border = '3px solid #0ff';
            console.log('Theme applied:', themeName, themes[themeName]);
        }
    });
});

document.getElementById('screenShakeToggle').addEventListener('change', (e) => {
    screenShakeEnabled = e.target.checked;
});

document.getElementById('particleToggle').addEventListener('change', (e) => {
    particleEffectsEnabled = e.target.checked;
});

document.getElementById('trailToggle').addEventListener('change', (e) => {
    bulletTrailsEnabled = e.target.checked;
});

document.getElementById('startGameWithWeaponBtn').addEventListener('click', () => {
    selectedWeaponP1 = selectedWeapon;
    player1.currentWeaponIndex = selectedWeaponP1;
    player2.currentWeaponIndex = selectedWeapon;
    document.getElementById('weapon-selection-modal').style.display = 'none';
    startGame();
});

window.addEventListener('load', () => {
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('pause-btn').style.display = 'none';
    initWeaponSelection();
});
</script>
</body>
</html>
