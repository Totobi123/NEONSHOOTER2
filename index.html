<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Defender 1v1</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .hud-element { position: absolute; color: white; font-weight: bold; pointer-events: none; }
        #p1-health-bar { top: 20px; left: 20px; width: 200px; height: 20px; border: 2px solid #fff; border-radius: 10px; background: #444; }
        #p1-health-fill { height: 100%; width: 100%; background: #0f0; border-radius: 10px; transition: width 0.2s, background 0.2s; }
        #p1-label { top: 5px; left: 20px; font-size: 14px; color: cyan; }
        #p2-health-bar { top: 20px; right: 20px; width: 200px; height: 20px; border: 2px solid #fff; border-radius: 10px; background: #444; }
        #p2-health-fill { height: 100%; width: 100%; background: #0f0; border-radius: 10px; transition: width 0.2s, background 0.2s; }
        #p2-label { top: 5px; right: 20px; font-size: 14px; color: magenta; text-align: right; }
        #pause-btn { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: #ff6b00; border: 2px solid white; padding: 10px 20px; font-size: 16px; color: white; cursor: pointer; border-radius: 5px; pointer-events: auto; z-index: 100; }
        #pause-btn:hover { background: #ff8c00; }
        .menu-box { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); padding: 40px; border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto; box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); }
        h1 { color: #fff; margin: 0 0 20px 0; font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px cyan; }
        p { color: #ccc; font-size: 1.2rem; margin-bottom: 30px; }
        button { background: linear-gradient(45deg, #00f260, #0575e6); border: none; padding: 15px 40px; color: white; font-size: 1.5rem; border-radius: 50px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; font-weight: bold; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(5, 117, 230, 0.6); }
        .mode-btn { margin: 10px; padding: 12px 35px; font-size: 1.3rem; border-radius: 30px; border: none; cursor: pointer; font-weight: bold; background: linear-gradient(45deg, #f093fb, #f5576c); color: white; }
        .mode-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(245, 87, 108, 0.6); }
        input { padding: 10px; font-size: 16px; border-radius: 5px; border: none; width: 200px; text-align: center; }
        #pause-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-layer">
    <div id="p1-label" class="hud-element">Player 1</div>
    <div id="p1-health-bar" class="hud-element"><div id="p1-health-fill"></div></div>
    <div id="p2-label" class="hud-element">Player 2</div>
    <div id="p2-health-bar" class="hud-element"><div id="p2-health-fill"></div></div>
    <button id="pause-btn">PAUSE (ESC)</button>
    
    <div id="start-modal" class="menu-box">
        <h1>Neon Defender</h1>
        <p>1v1 PvP - Click to Start</p>
        <button id="localModeBtn" class="mode-btn">LOCAL 1v1</button>
        <button id="onlineModeBtn" class="mode-btn">ONLINE 1v1</button>
        <p style="margin-top:20px; font-size:0.9rem;">P1: WASD to Move, Click or ENTER to Shoot | P2: Arrow Keys to Move, SHIFT to Shoot</p>
    </div>
    
    <div id="local-choice-modal" class="menu-box" style="display: none;">
        <h1>Local Mode</h1>
        <p>Choose Your Opponent:</p>
        <button id="vs-bot-btn" class="mode-btn">VS BOT</button>
        <button id="vs-player-btn" class="mode-btn">VS PLAYER</button>
        <button id="backToMainBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
    </div>
    
    <div id="difficulty-modal" class="menu-box" style="display: none;">
        <h1>Choose Bot Difficulty</h1>
        <p>Select difficulty:</p>
        <button id="easy-btn" class="mode-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049);">EASY</button>
        <button id="medium-btn" class="mode-btn" style="background: linear-gradient(45deg, #ff9800, #e68900);">MEDIUM</button>
        <button id="hard-btn" class="mode-btn" style="background: linear-gradient(45deg, #f44, #c00);">HARD</button>
        <button id="backToCHoiceBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
    </div>
    
    <div id="detection-modal" class="menu-box" style="display: none;">
        <h1>Detect Keyboards</h1>
        <p>Press keys on your keyboards to detect them...</p>
        <div style="margin-top: 20px; font-size: 1rem; color: #0f0;">
            <div id="keyboard-list" style="text-align: left; margin: 20px auto; width: 300px; max-height: 150px; overflow-y: auto; border: 1px solid #0f0; padding: 10px; border-radius: 5px;">
                <p style="color: #888;">Waiting for keyboard input...</p>
            </div>
        </div>
        <p id="detection-status" style="margin-top: 20px; font-size: 0.85rem; color: #ff9800;">Detected 0 keyboards</p>
        <button id="continueDetectionBtn" class="mode-btn" style="background: linear-gradient(45deg, #4CAF50, #45a049); margin-top: 20px; display: none;">CONTINUE (Found 2+)</button>
        <button id="skipDetectionBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">USE DEFAULTS</button>
    </div>
    
    <div id="calibration-modal" class="menu-box" style="display: none;">
        <h1 id="calibration-title">Assign Keyboards</h1>
        <p id="calibration-text">Select which keyboard for Player 1:</p>
        <div style="margin-top: 20px; text-align: left; margin-left: 50px;">
            <div id="keyboard-selector" style="margin-bottom: 20px;"></div>
        </div>
        <div style="margin-top: 20px; font-size: 1rem; color: #0f0;">
            <p id="p1-keyboard-status">Keyboard: <span style="color: #888;">Select above</span></p>
            <p id="p1-mouse-status">Mouse: <span style="color: #888;">Click anywhere</span></p>
            <p id="p2-keyboard-status" style="margin-top: 15px; display: none;">Keyboard: <span style="color: #0f0;">✓ Auto-assigned</span></p>
            <p id="p2-mouse-status" style="display: none;">Mouse: <span style="color: #888;">Click anywhere</span></p>
        </div>
        <button id="skipCalibrationBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">USE DEFAULTS (WASD + Arrows)</button>
    </div>
    
    <div id="online-modal" class="menu-box" style="display: none;">
        <h1>Online 1v1</h1>
        <p>Connect with a Player:</p>
        <button id="randomMatchBtn" class="mode-btn">RANDOM MATCH</button>
        <button id="codeMatchBtn" class="mode-btn">ENTER CODE</button>
        <button id="backFromOnlineBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444); margin-top: 20px;">BACK</button>
        
        <div id="code-section" style="display: none; margin-top: 20px;">
            <p>Your Code:</p>
            <input type="text" id="codeInput" placeholder="Enter or create code" maxlength="6">
            <p style="margin-top: 15px; font-size: 0.9rem;">Share this code with a friend</p>
            <button id="codeConnectBtn" class="mode-btn" style="margin-top: 10px;">CONNECT</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="menu-box" style="display: none;">
        <h1 id="winner-text">Player 1 Wins!</h1>
        <p style="font-size: 1rem; margin: 20px 0;">Victory!</p>
        <button id="homeBtn" class="mode-btn">HOME</button>
    </div>
    
    <div id="pause-modal" class="menu-box">
        <h1>PAUSED</h1>
        <button id="resumeBtn" class="mode-btn">RESUME (ESC)</button>
        <button id="homeFromPauseBtn" class="mode-btn" style="background: linear-gradient(45deg, #666, #444);">HOME</button>
    </div>
    
    <div id="matching-modal" class="menu-box" style="display: none;">
        <h1>Finding Match...</h1>
        <p id="matching-text">Connecting to a random player...</p>
        <button id="cancelMatchBtn" class="mode-btn" style="background: linear-gradient(45deg, #f44, #c00); margin-top: 20px;">CANCEL</button>
    </div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

let gameActive = false;
let gamePaused = false;
let gameMode = null; // 'local' or 'online'
let localMode = null; // 'bot' or 'player'
let botDifficulty = 'medium'; // 'easy', 'medium', 'hard'
let animationId;
let isPlayingBot = false;

// Control registration
let calibrationMode = false;
let detectionMode = false;
let calibrationStep = 0; // 0 = select P1 kbd, 1 = P1 mouse, 2 = P2 mouse
let p1RegisteredKeys = new Set();
let p1RegisteredMouseButton = null;
let p2RegisteredKeys = new Set();
let p2RegisteredMouseButton = null;
let useDefaultControls = false;
let detectingKeyboards = true;
let detectedKeyboards = {}; // {keyboardId: {id, lastKeyCode, keyCount, name}}
let nextKeyboardId = 0;
let p1SelectedKeyboardId = null;
let p2SelectedKeyboardId = null;
let keyboardDetectionTimeout = null;

const weapons = [
    { name: 'Pistol', bullets: 1, speed: 15, damage: 10, fireRate: 200 },
    { name: 'Shotgun', bullets: 6, speed: 12, damage: 15, spread: 0.3, fireRate: 500 },
    { name: 'Sniper', bullets: 1, speed: 25, damage: 50, fireRate: 1000 }
];

class Player { 
    constructor(x, y, radius, color, isP2 = false) { 
        this.x = x; this.y = y; this.radius = radius; this.color = color; 
        this.velocity = { x: 0, y: 0 }; this.speed = 5; this.health = 100;
        this.isP2 = isP2;
        this.currentWeaponIndex = 0;
        this.lastShotTime = 0;
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.closePath(); ctx.shadowBlur = 0; }
    update(keys) {
        if(useDefaultControls) {
            if(this.isP2) {
                if(keys['ArrowUp']) this.y -= this.speed;
                if(keys['ArrowDown']) this.y += this.speed;
                if(keys['ArrowLeft']) this.x -= this.speed;
                if(keys['ArrowRight']) this.x += this.speed;
            } else {
                if(keys['KeyW']) this.y -= this.speed;
                if(keys['KeyS']) this.y += this.speed;
                if(keys['KeyA']) this.x -= this.speed;
                if(keys['KeyD']) this.x += this.speed;
            }
        } else {
            const registeredKeys = this.isP2 ? p2RegisteredKeys : p1RegisteredKeys;
            for(let key of registeredKeys) {
                if(key.includes('Up') || key.includes('W')) this.y -= this.speed;
                if(key.includes('Down') || key.includes('S')) this.y += this.speed;
                if(key.includes('Left') || key.includes('A')) this.x -= this.speed;
                if(key.includes('Right') || key.includes('D')) this.x += this.speed;
            }
            for(let k in keys) {
                if(registeredKeys.has(k) && keys[k]) {
                    if(k.includes('Up') || k.includes('W')) this.y -= this.speed;
                    if(k.includes('Down') || k.includes('S')) this.y += this.speed;
                    if(k.includes('Left') || k.includes('A')) this.x -= this.speed;
                    if(k.includes('Right') || k.includes('D')) this.x += this.speed;
                }
            }
        }
        
        if(this.x - this.radius < 0) this.x = this.radius;
        if(this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
        if(this.y - this.radius < 0) this.y = this.radius;
        if(this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
        this.draw();
    }
}

class Bot {
    constructor(x, y, radius, color, difficulty = 'medium') {
        this.x = x; this.y = y; this.radius = radius; this.color = color;
        this.velocity = { x: 0, y: 0 }; this.health = 100;
        this.difficulty = difficulty;
        this.speed = difficulty === 'easy' ? 2.5 : difficulty === 'medium' ? 4 : 5.5;
        this.fireRate = difficulty === 'easy' ? 800 : difficulty === 'medium' ? 500 : 300;
        this.lastShotTime = 0;
        this.currentWeaponIndex = 0;
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.closePath(); ctx.shadowBlur = 0; }
    update(player1) {
        const angle = Math.atan2(player1.y - this.y, player1.x - this.x);
        this.velocity = { x: Math.cos(angle) * this.speed, y: Math.sin(angle) * this.speed };
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        
        if(this.x - this.radius < 0) this.x = this.radius;
        if(this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
        if(this.y - this.radius < 0) this.y = this.radius;
        if(this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
        
        const now = Date.now();
        if(now - this.lastShotTime > this.fireRate) {
            this.lastShotTime = now;
            const weapon = weapons[this.currentWeaponIndex];
            const velocity = { x: Math.cos(angle) * weapon.speed, y: Math.sin(angle) * weapon.speed };
            projectiles.push(new Projectile(this.x, this.y, 5, this.color, velocity, weapon.damage, this));
        }
        this.draw();
    }
}

class Projectile { 
    constructor(x, y, radius, color, velocity, damage, owner) {
        this.x = x; this.y = y; this.radius = radius; this.color = color; 
        this.velocity = velocity; this.damage = damage; this.owner = owner;
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.closePath(); }
    update() { this.draw(); this.x += this.velocity.x; this.y += this.velocity.y; }
}

let player1 = new Player(canvas.width/4, canvas.height/2, 15, '#0ff', false);
let player2 = new Player(canvas.width * 3/4, canvas.height/2, 15, '#f0f', true);
let bot = null;
let projectiles = [];
const keys = {};
window.lastMouseX = canvas.width / 2;
window.lastMouseY = canvas.height / 2;

window.addEventListener('keydown', (e) => {
    if(detectionMode && detectingKeyboards) {
        // Detect keyboard by proximity - keys pressed close in time are from same keyboard
        const currentTime = Date.now();
        let assignedKeyboard = null;
        
        // Check if this key belongs to an existing keyboard (within 300ms of last key)
        for(let id in detectedKeyboards) {
            const kbd = detectedKeyboards[id];
            if(currentTime - kbd.lastKeyCode < 300) {
                assignedKeyboard = id;
                break;
            }
        }
        
        // If no matching keyboard, create new one
        if(assignedKeyboard === null) {
            assignedKeyboard = nextKeyboardId++;
            const chars = 'ABCDEFGH';
            detectedKeyboards[assignedKeyboard] = {
                id: assignedKeyboard,
                lastKeyCode: currentTime,
                keyCount: 1,
                name: 'Keyboard ' + chars[assignedKeyboard]
            };
        } else {
            detectedKeyboards[assignedKeyboard].lastKeyCode = currentTime;
            detectedKeyboards[assignedKeyboard].keyCount++;
        }
        
        updateKeyboardList();
        
        // Restart timeout
        clearTimeout(keyboardDetectionTimeout);
        keyboardDetectionTimeout = setTimeout(() => {
            if(Object.keys(detectedKeyboards).length >= 2) {
                proceedToCalibration();
            }
        }, 3000);
        
        return;
    }
    
    if(calibrationMode && calibrationStep < 2) {
        // Store keys for selected player
        if(p1SelectedKeyboardId !== null && calibrationStep === 0) {
            p1RegisteredKeys.add(e.code);
            document.getElementById('p1-keyboard-status').innerHTML = 'Keyboard: <span style="color: #0f0;">✓ Keys detected</span>';
            calibrationStep = 1;
        } else if(p2SelectedKeyboardId !== null && calibrationStep === 1) {
            p2RegisteredKeys.add(e.code);
            document.getElementById('p2-keyboard-status').innerHTML = 'Keyboard: <span style="color: #0f0;">✓ Keys detected</span>';
            calibrationStep = 2;
        }
    }
    
    // Player 1 shoot with ENTER key
    if(e.code === 'Enter') {
        if(!gameActive || gamePaused) return;
        const now = Date.now();
        const weapon = weapons[player1.currentWeaponIndex];
        const fireRate = weapon.fireRate;
        if(now - player1.lastShotTime < fireRate) return;
        player1.lastShotTime = now;
        // Shoot towards mouse position (or center if mouse not tracked)
        const angle = Math.atan2(window.lastMouseY - player1.y, window.lastMouseX - player1.x);
        for(let i = 0; i < weapon.bullets; i++) {
            let spreadAngle = angle;
            if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
            const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
            projectiles.push(new Projectile(player1.x, player1.y, 5, player1.color, velocity, weapon.damage, player1));
        }
        return;
    }
    
    keys[e.code] = true;
    if(e.code === 'Escape') togglePause();
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

window.addEventListener('mousemove', (event) => {
    window.lastMouseX = event.clientX;
    window.lastMouseY = event.clientY;
});

window.addEventListener('click', (event) => {
    if(calibrationMode && calibrationStep === 1) {
        p1RegisteredMouseButton = true;
        document.getElementById('p1-mouse-status').innerHTML = 'Mouse: <span style="color: #0f0;">✓ Registered</span>';
        calibrationStep = 2;
    } else if(calibrationMode && calibrationStep === 2) {
        p2RegisteredMouseButton = true;
        document.getElementById('p2-mouse-status').innerHTML = 'Mouse: <span style="color: #0f0;">✓ Registered</span>';
        setTimeout(completeCalibration, 500);
        return;
    }
    
    if(!gameActive || gamePaused) return;
    const now = Date.now();
    const weapon = weapons[player1.currentWeaponIndex];
    const fireRate = weapon.fireRate;
    if(now - player1.lastShotTime < fireRate) return;
    player1.lastShotTime = now;
    const angle = Math.atan2(event.clientY - player1.y, event.clientX - player1.x);
    for(let i = 0; i < weapon.bullets; i++) {
        let spreadAngle = angle;
        if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
        const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
        projectiles.push(new Projectile(player1.x, player1.y, 5, player1.color, velocity, weapon.damage, player1));
    }
});

window.addEventListener('keydown', (e) => {
    if(e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        if(!gameActive || gamePaused) return;
        const now = Date.now();
        const weapon = weapons[player2.currentWeaponIndex];
        const fireRate = weapon.fireRate;
        if(now - player2.lastShotTime < fireRate) return;
        player2.lastShotTime = now;
        const tx = player1.x;
        const ty = player1.y;
        const angle = Math.atan2(ty - player2.y, tx - player2.x);
        for(let i = 0; i < weapon.bullets; i++) {
            let spreadAngle = angle;
            if(weapon.name === 'Shotgun') spreadAngle += (Math.random() - 0.5) * weapon.spread;
            const velocity = {x: Math.cos(spreadAngle) * weapon.speed, y: Math.sin(spreadAngle) * weapon.speed};
            projectiles.push(new Projectile(player2.x, player2.y, 5, player2.color, velocity, weapon.damage, player2));
        }
    }
});

function animate() {
    if(!gameActive) return;
    animationId = requestAnimationFrame(animate);
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if(!gamePaused) {
        player1.update(keys);
        if(isPlayingBot) {
            bot.update(player1);
            const opponent = bot;
            projectiles.forEach((p, i) => {
                p.update();
                if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    return;
                }
                
                if(p.owner === player1) {
                    const dist = Math.hypot(p.x - opponent.x, p.y - opponent.y);
                    if(dist < p.radius + opponent.radius) {
                        opponent.health -= p.damage;
                        projectiles.splice(i, 1);
                        updateHealthBars();
                        if(opponent.health <= 0) {
                            endGame(player1);
                        }
                    }
                } else {
                    const dist = Math.hypot(p.x - player1.x, p.y - player1.y);
                    if(dist < p.radius + player1.radius) {
                        player1.health -= p.damage;
                        projectiles.splice(i, 1);
                        updateHealthBars();
                        if(player1.health <= 0) {
                            endGame(opponent);
                        }
                    }
                }
            });
        } else {
            player2.update(keys);
            projectiles.forEach((p, i) => {
                p.update();
                if(p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                    projectiles.splice(i, 1);
                    return;
                }
                
                const checkPlayer = p.owner === player1 ? player2 : player1;
                const dist = Math.hypot(p.x - checkPlayer.x, p.y - checkPlayer.y);
                if(dist < p.radius + checkPlayer.radius) {
                    checkPlayer.health -= p.damage;
                    projectiles.splice(i, 1);
                    updateHealthBars();
                    
                    if(checkPlayer.health <= 0) {
                        endGame(p.owner === player1 ? player1 : player2);
                    }
                }
            });
        }
    }
}

function updateHealthBars() {
    document.getElementById('p1-health-fill').style.width = Math.max(0, player1.health) + '%';
    const p1Percent = Math.max(0, player1.health);
    document.getElementById('p1-health-fill').style.background = p1Percent > 50 ? '#0f0' : p1Percent > 20 ? '#ff0' : '#f00';
    
    const p2Health = isPlayingBot ? (bot ? bot.health : 100) : player2.health;
    document.getElementById('p2-health-fill').style.width = Math.max(0, p2Health) + '%';
    const p2Percent = Math.max(0, p2Health);
    document.getElementById('p2-health-fill').style.background = p2Percent > 50 ? '#0f0' : p2Percent > 20 ? '#ff0' : '#f00';
}

function startGame() {
    player1.health = 100;
    player1.x = canvas.width/4;
    player1.y = canvas.height/2;
    projectiles = [];
    gameActive = true;
    gamePaused = false;
    
    if(isPlayingBot) {
        bot = new Bot(canvas.width * 3/4, canvas.height/2, 15, '#f0f', botDifficulty);
        document.getElementById('p2-label').innerText = 'Bot (' + botDifficulty.toUpperCase() + ')';
    } else {
        player2.health = 100;
        player2.x = canvas.width * 3/4;
        player2.y = canvas.height/2;
        document.getElementById('p2-label').innerText = 'Player 2';
    }
    
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'block';
    updateHealthBars();
    animate();
}

function endGame(winner) {
    gameActive = false;
    cancelAnimationFrame(animationId);
    if(isPlayingBot) {
        document.getElementById('winner-text').innerText = winner === player1 ? 'You Win!' : 'Bot Wins!';
    } else {
        document.getElementById('winner-text').innerText = winner === player1 ? 'Player 1 Wins!' : 'Player 2 Wins!';
    }
    document.getElementById('game-over-modal').style.display = 'flex';
    document.getElementById('pause-btn').style.display = 'none';
}

function togglePause() {
    if(!gameActive) return;
    gamePaused = !gamePaused;
    document.getElementById('pause-modal').style.display = gamePaused ? 'flex' : 'none';
}

function startDetection() {
    detectionMode = true;
    detectingKeyboards = true;
    detectedKeyboards = {};
    nextKeyboardId = 0;
    p1SelectedKeyboardId = null;
    p2SelectedKeyboardId = null;
    
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('detection-modal').style.display = 'flex';
    updateKeyboardList();
    
    // Stop detection after 10 seconds of inactivity
    clearTimeout(keyboardDetectionTimeout);
    keyboardDetectionTimeout = setTimeout(() => {
        if(Object.keys(detectedKeyboards).length >= 2) {
            proceedToCalibration();
        } else {
            updateDetectionStatus();
        }
    }, 10000);
}

function updateKeyboardList() {
    const list = document.getElementById('keyboard-list');
    if(Object.keys(detectedKeyboards).length === 0) {
        list.innerHTML = '<p style="color: #888;">Waiting for keyboard input...</p>';
        return;
    }
    
    let html = '';
    for(let id in detectedKeyboards) {
        const kbd = detectedKeyboards[id];
        html += `<p style="margin: 5px 0; color: #0f0;">▌ ${kbd.name} (${kbd.keyCount} keys)</p>`;
    }
    list.innerHTML = html;
    updateDetectionStatus();
}

function updateDetectionStatus() {
    const count = Object.keys(detectedKeyboards).length;
    const status = document.getElementById('detection-status');
    const btn = document.getElementById('continueDetectionBtn');
    
    status.innerText = `Detected ${count} keyboard${count !== 1 ? 's' : ''}`;
    if(count >= 2) {
        btn.style.display = 'block';
        status.style.color = '#0f0';
    } else {
        btn.style.display = 'none';
        status.style.color = '#ff9800';
    }
}

function proceedToCalibration() {
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    
    if(Object.keys(detectedKeyboards).length < 2) {
        alert('Only 1 keyboard detected. Click USE DEFAULTS to continue with keyboard 1.');
        return;
    }
    
    document.getElementById('detection-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'flex';
    buildKeyboardSelector();
}

function buildKeyboardSelector() {
    const selector = document.getElementById('keyboard-selector');
    let html = '';
    for(let id in detectedKeyboards) {
        const kbd = detectedKeyboards[id];
        html += `<label style="display: block; margin: 10px 0; cursor: pointer;">
                    <input type="radio" name="p1-keyboard" value="${id}" style="cursor: pointer;"> ${kbd.name}
                 </label>`;
    }
    selector.innerHTML = html;
    
    // Add change listener
    document.querySelectorAll('input[name="p1-keyboard"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            p1SelectedKeyboardId = e.target.value;
            document.getElementById('p1-keyboard-status').innerHTML = `Keyboard: <span style="color: #0f0;">✓ ${detectedKeyboards[p1SelectedKeyboardId].name}</span>`;
            
            // Auto-assign other keyboard to P2
            for(let id in detectedKeyboards) {
                if(id !== p1SelectedKeyboardId) {
                    p2SelectedKeyboardId = id;
                    break;
                }
            }
            if(p2SelectedKeyboardId) {
                document.getElementById('p2-keyboard-status').innerHTML = `Keyboard: <span style="color: #0f0;">✓ ${detectedKeyboards[p2SelectedKeyboardId].name}</span>`;
            }
        });
    });
}

function startCalibration() {
    startDetection();
}

function completeCalibration() {
    calibrationMode = false;
    detectionMode = false;
    isPlayingBot = false;
    startGame();
}

function goHome() {
    gameActive = false;
    gamePaused = false;
    calibrationMode = false;
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    cancelAnimationFrame(animationId);
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('detection-modal').style.display = 'none';
    document.getElementById('calibration-modal').style.display = 'none';
    document.getElementById('game-over-modal').style.display = 'none';
    document.getElementById('pause-modal').style.display = 'none';
    document.getElementById('pause-btn').style.display = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

// Event Listeners
document.getElementById('localModeBtn').addEventListener('click', () => {
    gameMode = 'local';
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'flex';
});

document.getElementById('vs-bot-btn').addEventListener('click', () => {
    isPlayingBot = true;
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('difficulty-modal').style.display = 'flex';
});

document.getElementById('vs-player-btn').addEventListener('click', () => {
    startCalibration();
});

document.getElementById('easy-btn').addEventListener('click', () => {
    botDifficulty = 'easy';
    startGame();
});

document.getElementById('medium-btn').addEventListener('click', () => {
    botDifficulty = 'medium';
    startGame();
});

document.getElementById('hard-btn').addEventListener('click', () => {
    botDifficulty = 'hard';
    startGame();
});

document.getElementById('backToMainBtn').addEventListener('click', () => {
    document.getElementById('local-choice-modal').style.display = 'none';
    document.getElementById('start-modal').style.display = 'flex';
});

document.getElementById('backToCHoiceBtn').addEventListener('click', () => {
    document.getElementById('difficulty-modal').style.display = 'none';
    document.getElementById('local-choice-modal').style.display = 'flex';
});

document.getElementById('onlineModeBtn').addEventListener('click', () => {
    document.getElementById('start-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'flex';
});

document.getElementById('randomMatchBtn').addEventListener('click', () => {
    const code = Math.random().toString(36).substring(2, 8).toUpperCase();
    localStorage.setItem('matchCode', code);
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('matching-modal').style.display = 'flex';
    document.getElementById('matching-text').innerText = 'Your Code: ' + code + '\nWaiting for opponent...';
    setTimeout(startGame, 3000);
});

document.getElementById('codeMatchBtn').addEventListener('click', () => {
    document.getElementById('code-section').style.display = 'block';
    document.getElementById('codeInput').value = '';
    document.getElementById('codeInput').focus();
});

document.getElementById('codeConnectBtn').addEventListener('click', () => {
    const code = document.getElementById('codeInput').value.toUpperCase();
    if(code.length < 3) { alert('Code must be at least 3 characters'); return; }
    localStorage.setItem('matchCode', code);
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('matching-modal').style.display = 'flex';
    document.getElementById('matching-text').innerText = 'Connecting with code: ' + code + '...';
    setTimeout(startGame, 2000);
});

document.getElementById('backFromOnlineBtn').addEventListener('click', () => {
    document.getElementById('online-modal').style.display = 'none';
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('code-section').style.display = 'none';
});

document.getElementById('cancelMatchBtn').addEventListener('click', () => {
    document.getElementById('matching-modal').style.display = 'none';
    document.getElementById('online-modal').style.display = 'flex';
});

document.getElementById('skipDetectionBtn').addEventListener('click', () => {
    useDefaultControls = true;
    detectionMode = false;
    detectingKeyboards = false;
    clearTimeout(keyboardDetectionTimeout);
    isPlayingBot = false;
    document.getElementById('detection-modal').style.display = 'none';
    startGame();
});

document.getElementById('continueDetectionBtn').addEventListener('click', proceedToCalibration);

document.getElementById('skipCalibrationBtn').addEventListener('click', () => {
    useDefaultControls = true;
    calibrationMode = false;
    detectionMode = false;
    isPlayingBot = false;
    document.getElementById('calibration-modal').style.display = 'none';
    startGame();
});

document.getElementById('homeBtn').addEventListener('click', goHome);
document.getElementById('homeFromPauseBtn').addEventListener('click', goHome);
document.getElementById('resumeBtn').addEventListener('click', togglePause);

window.addEventListener('load', () => {
    document.getElementById('start-modal').style.display = 'flex';
    document.getElementById('pause-btn').style.display = 'none';
});
</script>
</body>
</html>
