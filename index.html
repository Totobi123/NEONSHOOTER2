<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Survival Shooter</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .hud-element { position: absolute; color: white; font-weight: bold; pointer-events: none; }
        #score-board { top: 20px; left: 20px; font-size: 24px; }
        #health-bar { top: 20px; right: 20px; width: 200px; height: 20px; border: 2px solid #fff; border-radius: 10px; background: #444; }
        #health-fill { height: 100%; width: 100%; background: #0f0; border-radius: 10px; transition: width 0.2s, background 0.2s; }
        .menu-box { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); padding: 40px; border-radius: 16px; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto; box-shadow: 0 0 50px rgba(0, 255, 255, 0.2); }
        h1 { color: #fff; margin: 0 0 20px 0; font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px cyan; }
        p { color: #ccc; font-size: 1.2rem; margin-bottom: 30px; }
        button { background: linear-gradient(45deg, #00f260, #0575e6); border: none; padding: 15px 40px; color: white; font-size: 1.5rem; border-radius: 50px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; font-weight: bold; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(5, 117, 230, 0.6); }
        #game-over-modal { display: none; }
        #weapon-hud { top: 60px; left: 20px; font-size: 20px; }
        .difficulty-btn { margin: 10px; padding: 10px 30px; font-size: 1.2rem; border-radius: 30px; border: none; cursor: pointer; font-weight: bold; background: linear-gradient(45deg, #ff512f, #dd2476); color: white; }
        .difficulty-btn:hover { transform: scale(1.05); }
        .mode-btn { margin: 10px; padding: 12px 35px; font-size: 1.3rem; border-radius: 30px; border: none; cursor: pointer; font-weight: bold; background: linear-gradient(45deg, #f093fb, #f5576c); color: white; }
        .mode-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(245, 87, 108, 0.6); }
        #mode-hud { top: 90px; left: 20px; font-size: 18px; color: #f5576c; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-layer">
    <div id="score-board" class="hud-element">Score: 0</div>
    <div id="health-bar" class="hud-element"><div id="health-fill"></div></div>
    <div id="weapon-hud" class="hud-element">Weapon: Pistol</div>
    <div id="mode-hud" class="hud-element">Mode: Normal</div>
    <div id="start-modal" class="menu-box">
        <h1>Neon Defender</h1>
        <p>Choose Game Mode:</p>
        <button class="mode-btn" id="normalModeBtn">NORMAL MODE</button>
        <button class="mode-btn" id="brModeBtn">BATTLE ROYALE MODE</button>
        <p style="margin-top:20px;">Choose Difficulty:</p>
        <button class="difficulty-btn" data-difficulty="easy">EASY</button>
        <button class="difficulty-btn" data-difficulty="medium">MEDIUM</button>
        <button class="difficulty-btn" data-difficulty="hard">HARD</button>
        <p style="margin-top:20px; font-size:1rem;">WASD to Move | Mouse to Aim | Click to Shoot | 1-3 to Switch Weapon</p>
    </div>
    <div id="game-over-modal" class="menu-box">
        <h1>Game Over</h1>
        <p id="final-score">Score: 0</p>
        <button id="restartBtn">TRY AGAIN</button>
    </div>
</div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-board');
const healthFill = document.getElementById('health-fill');
const weaponHud = document.getElementById('weapon-hud');
const modeHud = document.getElementById('mode-hud');
const startModal = document.getElementById('start-modal');
const gameOverModal = document.getElementById('game-over-modal');
const finalScoreEl = document.getElementById('final-score');
const restartBtn = document.getElementById('restartBtn');

let animationId;
let score = 0;
let gameActive = false;
let playerHealth = 100;
let difficulty = 'medium';
let gameMode = 'normal';
let brStartTime = 0;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

const weapons = [
    { name: 'Pistol', bullets: 1, speed: 15, damage: 10, fireRate: 200 },
    { name: 'Shotgun', bullets: 6, speed: 12, damage: 15, spread: 0.3, fireRate: 500 },
    { name: 'Sniper', bullets: 1, speed: 25, damage: 50, fireRate: 1000 }
];
let currentWeaponIndex = 0;
let lastShotTime = 0;

class Player { constructor(x, y, radius, color) { this.x = x; this.y = y; this.radius = radius; this.color = color; this.velocity = { x: 0, y: 0 }; this.speed = 5; this.shield = false; this.rapidFire = false; }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2,false); ctx.fillStyle=this.color; ctx.fill(); ctx.shadowBlur=15; ctx.shadowColor=this.color; ctx.closePath(); ctx.shadowBlur=0; }
    update(keys){ if(keys['KeyW']||keys['ArrowUp']) this.y-=this.speed; if(keys['KeyS']||keys['ArrowDown']) this.y+=this.speed; if(keys['KeyA']||keys['ArrowLeft']) this.x-=this.speed; if(keys['KeyD']||keys['ArrowRight']) this.x+=this.speed; if(this.x-this.radius<0) this.x=this.radius; if(this.x+this.radius>canvas.width)this.x=canvas.width-this.radius; if(this.y-this.radius<0)this.y=this.radius; if(this.y+this.radius>canvas.height)this.y=canvas.height-this.radius; this.draw(); }
}

class Projectile { constructor(x,y,radius,color,velocity,damage,owner=null){ this.x=x; this.y=y; this.radius=radius; this.color=color; this.velocity=velocity; this.damage=damage; this.owner=owner; }
    draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false); ctx.fillStyle=this.color; ctx.fill(); ctx.closePath(); }
    update(){ this.draw(); this.x+=this.velocity.x; this.y+=this.velocity.y; }
}

class Enemy {
    constructor(x,y,type){
        this.x=x; this.y=y; this.type=type;
        let speedMultiplier = difficulty==='easy'?0.6:difficulty==='medium'?1:1.4;
        if(type==='fast'){ this.radius=10; this.speed=4*speedMultiplier; this.health=20; this.color='#ff0'; }
        else if(type==='tank'){ this.radius=25; this.speed=1.5*speedMultiplier; this.health=100; this.color='#f00'; }
        else if(type==='ranged'){ this.radius=15; this.speed=2*speedMultiplier; this.health=30; this.color='#0ff'; this.shootCooldown=0; }
        else{ this.radius=15; this.speed=2*speedMultiplier; this.health=30; this.color='#f0f'; }
        this.lastShotTime = 0;
    }
    draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false); ctx.fillStyle=this.color; ctx.fill(); ctx.closePath(); }
    update(player){ const angle=Math.atan2(player.y-this.y,player.x-this.x); this.velocity={ x: Math.cos(angle)*this.speed, y: Math.sin(angle)*this.speed }; this.x+=this.velocity.x; this.y+=this.velocity.y; this.draw(); }
    updateBR(enemies, index) {
        if (enemies.length <= 1) { this.draw(); return; }
        let closestEnemy = null;
        let closestDist = Infinity;
        enemies.forEach((enemy, i) => {
            if (i !== index) {
                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist < closestDist) { closestDist = dist; closestEnemy = enemy; }
            }
        });
        if (closestEnemy) {
            const angle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
            this.velocity = { x: Math.cos(angle) * this.speed, y: Math.sin(angle) * this.speed };
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            if (this.x - this.radius < 0) this.x = this.radius;
            if (this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
            if (this.y - this.radius < 0) this.y = this.radius;
            if (this.y + this.radius > canvas.height) this.y = canvas.height - this.radius;
            const now = Date.now();
            if (now - this.lastShotTime > 800 && closestDist < 400) {
                this.lastShotTime = now;
                const velocity = { x: Math.cos(angle) * 8, y: Math.sin(angle) * 8 };
                enemyProjectiles.push(new Projectile(this.x, this.y, 4, this.color, velocity, 15, this));
            }
        }
        this.draw();
    }
    takeDamage(amount){ this.health-=amount; return this.health<=0; }
}

class Particle { constructor(x,y,radius,color,velocity){ this.x=x; this.y=y; this.radius=radius; this.color=color; this.velocity=velocity; this.life=30; }
    update(){ this.x+=this.velocity.x; this.y+=this.velocity.y; this.life--; this.draw(); }
    draw(){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2,false); ctx.fillStyle=this.color; ctx.fill(); ctx.closePath(); }
}

class PowerUp {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.type = type;
        this.baseY = y;
        this.floatOffset = 0;
        this.color = type==='health'?'#0f0':type==='shield'?'#00f':type==='rapid'?'#f90':'#f0f';
    }
    draw() {
        this.floatOffset += 0.05;
        const floatY = Math.sin(this.floatOffset) * 5;
        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.baseY + floatY, this.radius, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.restore();

        if(Math.random()<0.1){
            particles.push(new Particle(this.x + (Math.random()-0.5)*this.radius, this.baseY + floatY + (Math.random()-0.5)*this.radius, 2, this.color, {x:(Math.random()-0.5)*2, y:(Math.random()-0.5)*2}));
        }
    }
    apply(player){
        if(this.type==='health'){ playerHealth=Math.min(100,playerHealth+25); updateHealthBar(); }
        else if(this.type==='shield'){ player.shield=true; setTimeout(()=>{player.shield=false;},5000); }
        else if(this.type==='rapid'){ player.rapidFire=true; setTimeout(()=>{player.rapidFire=false;},5000); }
        else if(this.type==='bomb'){ enemies=[]; score+=50; scoreEl.innerText=`Score: ${score}`; }
    }
}

let player = new Player(canvas.width/2,canvas.height/2,15,'#fff');
let projectiles = [];
let enemyProjectiles = [];
let enemies = [];
let particles = [];
let powerUps = [];
let spawnInterval;
const keys = {};

window.addEventListener('keydown',(e)=>{ keys[e.code]=true; if(['Digit1','Digit2','Digit3'].includes(e.code)){ currentWeaponIndex=parseInt(e.code[5])-1; weaponHud.innerText=`Weapon: ${weapons[currentWeaponIndex].name}`; } });
window.addEventListener('keyup',(e)=>keys[e.code]=false);

window.addEventListener('click',(event)=>{
    if(!gameActive) return;
    const now=Date.now();
    const weapon=weapons[currentWeaponIndex];
    const fireRate=player.rapidFire?weapon.fireRate/3:weapon.fireRate;
    if(now-lastShotTime<fireRate) return;
    lastShotTime=now;
    const angle=Math.atan2(event.clientY-player.y,event.clientX-player.x);
    for(let i=0;i<weapon.bullets;i++){
        let spreadAngle=angle;
        if(weapon.name==='Shotgun'){ spreadAngle+=(Math.random()-0.5)*weapon.spread; }
        const velocity={x:Math.cos(spreadAngle)*weapon.speed,y:Math.sin(spreadAngle)*weapon.speed};
        projectiles.push(new Projectile(player.x,player.y,5,'cyan',velocity,weapon.damage));
    }
});

function spawnEnemies(){
    // For BR mode, spawn initial batch of enemies
    if(gameMode === 'br') {
        for(let i = 0; i < 100; i++) {
            const types = ['fast','tank','ranged','basic'];
            const type = types[Math.floor(Math.random() * types.length)];
            let spawnX = Math.random() * canvas.width;
            let spawnY = Math.random() * canvas.height;
            enemies.push(new Enemy(spawnX, spawnY, type));
        }
    }
    
    spawnInterval = setInterval(() => {
        if(!gameActive) return;
        const types = ['fast','tank','ranged','basic'];
        const type = types[Math.floor(Math.random() * types.length)];
        let spawnX = Math.random() * canvas.width;
        let spawnY = gameMode === 'br' ? Math.random() * canvas.height : -30;
        enemies.push(new Enemy(spawnX, spawnY, type));

        // 50% chance to drop power-up on enemy spawn (normal mode only)
        if(gameMode === 'normal' && Math.random() < 0.5){
            const puTypes = ['health','shield','rapid','bomb'];
            powerUps.push(new PowerUp(spawnX, spawnY, puTypes[Math.floor(Math.random()*puTypes.length)]));
        }
    }, gameMode === 'br' ? 500 : (difficulty==='easy'?1500 : difficulty==='medium'?1000 : 700));

    // Additional random power-ups every 6 seconds (normal mode only)
    if(gameMode === 'normal') {
        setInterval(() => {
            if(!gameActive) return;
            const puTypes = ['health','shield','rapid','bomb'];
            const x = Math.random() * (canvas.width-40) + 20;
            const y = Math.random() * (canvas.height-40) + 20;
            powerUps.push(new PowerUp(x, y, puTypes[Math.floor(Math.random()*puTypes.length)]));
        }, 6000);
    }
}

function init(){
    player=new Player(canvas.width/2,canvas.height/2,15,'#fff');
    projectiles=[]; enemyProjectiles=[]; enemies=[]; particles=[]; powerUps=[];
    score=0; playerHealth=100; scoreEl.innerText=`Score: ${score}`;
    healthFill.style.width=`100%`; healthFill.style.background=`#0f0`;
    gameActive=true;
    weaponHud.innerText=`Weapon: ${weapons[currentWeaponIndex].name}`;
    modeHud.innerText=`Mode: ${gameMode === 'br' ? 'Battle Royale' : 'Normal'}`;
    if(gameMode === 'br') brStartTime = Date.now();
}

function animate(){
    if(!gameActive) return;
    animationId=requestAnimationFrame(animate);
    ctx.fillStyle='rgba(0,0,0,0.1)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    
    if(gameMode === 'normal') {
        player.update(keys);
        powerUps.forEach((pu,index)=>{ pu.draw(); const dist=Math.hypot(player.x-pu.x,player.y-pu.y); if(dist<player.radius+pu.radius){ pu.apply(player); powerUps.splice(index,1); } });
    } else {
        player.draw();
    }

    projectiles.forEach((projectile,index)=>{ projectile.update(); if(projectile.x+projectile.radius<0||projectile.x-projectile.radius>canvas.width||projectile.y+projectile.radius<0||projectile.y-projectile.radius>canvas.height){ setTimeout(()=>{projectiles.splice(index,1);},0); } });
    
    enemyProjectiles.forEach((projectile,index)=>{ projectile.update(); if(projectile.x+projectile.radius<0||projectile.x-projectile.radius>canvas.width||projectile.y+projectile.radius<0||projectile.y-projectile.radius>canvas.height){ setTimeout(()=>{enemyProjectiles.splice(index,1);},0); } });

    particles.forEach((p,i)=>{ p.update(); if(p.life<=0) particles.splice(i,1); });

    enemies.forEach((enemy,index)=>{
        if(gameMode === 'br') {
            enemy.updateBR(enemies, index);
        } else {
            enemy.update(player);
            const dist=Math.hypot(player.x-enemy.x,player.y-enemy.y);
            if(dist-enemy.radius-player.radius<1){ if(!player.shield) playerHealth-=20; updateHealthBar(); enemies.splice(index,1); if(playerHealth<=0){ cancelAnimationFrame(animationId); gameActive=false; clearInterval(spawnInterval); finalScoreEl.innerText=`Score: ${score}`; gameOverModal.style.display='block'; } }
        }
        
        if(gameMode === 'normal') {
            projectiles.forEach((projectile,pIndex)=>{
                const distProj=Math.hypot(projectile.x-enemy.x,projectile.y-enemy.y);
                if(distProj-enemy.radius-projectile.radius<1){
                    for(let i=0;i<enemy.radius*2;i++){ particles.push(new Particle(projectile.x,projectile.y,Math.random()*2,enemy.color,{x:(Math.random()-0.5)*(Math.random()*6),y:(Math.random()-0.5)*(Math.random()*6)})); }
                    const destroyed=enemy.takeDamage(projectile.damage);
                    if(destroyed){ score+=projectile.damage*2; enemies.splice(index,1); } else { score+=projectile.damage; enemy.radius=Math.max(5,enemy.radius-5); }
                    scoreEl.innerText=`Score: ${score}`;
                    setTimeout(()=>{projectiles.splice(pIndex,1);},0);
                }
            });
        }
    });
    
    if(gameMode === 'br') {
        enemyProjectiles.forEach((projectile,pIndex)=>{
            enemies.forEach((enemy,eIndex)=>{
                if(projectile.owner === enemy) return;
                const distProj=Math.hypot(projectile.x-enemy.x,projectile.y-enemy.y);
                if(distProj-enemy.radius-projectile.radius<1){
                    for(let i=0;i<enemy.radius*2;i++){ particles.push(new Particle(projectile.x,projectile.y,Math.random()*2,enemy.color,{x:(Math.random()-0.5)*(Math.random()*6),y:(Math.random()-0.5)*(Math.random()*6)})); }
                    const destroyed=enemy.takeDamage(projectile.damage);
                    if(destroyed){ score+=15; enemies.splice(eIndex,1); } else { enemy.radius=Math.max(5,enemy.radius-2); }
                    scoreEl.innerText=`Score: ${score}`;
                    setTimeout(()=>{enemyProjectiles.splice(pIndex,1);},0);
                }
            });
        });
        
        const elapsedTime = Date.now() - brStartTime;
        if(elapsedTime > 10000 && enemies.length <= 1) {
            score += 500;
            scoreEl.innerText=`Score: ${score}`;
            cancelAnimationFrame(animationId);
            gameActive=false;
            clearInterval(spawnInterval);
            finalScoreEl.innerText=`Score: ${score} - ${enemies.length === 1 ? 'Last Enemy Standing!' : 'All Enemies Eliminated!'}`;
            gameOverModal.style.display='block';
        }
    }
}

function updateHealthBar(){ const percent=Math.max(0,playerHealth); healthFill.style.width=percent+'%'; if(percent>50) healthFill.style.background='#0f0'; else if(percent>20) healthFill.style.background='#ff0'; else healthFill.style.background='#f00'; }

document.getElementById('normalModeBtn').addEventListener('click', () => { gameMode = 'normal'; document.getElementById('normalModeBtn').style.background = 'linear-gradient(45deg, #4CAF50, #45a049)'; document.getElementById('brModeBtn').style.background = 'linear-gradient(45deg, #f093fb, #f5576c)'; });

document.getElementById('brModeBtn').addEventListener('click', () => { gameMode = 'br'; document.getElementById('brModeBtn').style.background = 'linear-gradient(45deg, #4CAF50, #45a049)'; document.getElementById('normalModeBtn').style.background = 'linear-gradient(45deg, #f093fb, #f5576c)'; });

document.querySelectorAll('.difficulty-btn').forEach(btn=>{ btn.addEventListener('click',()=>{ difficulty=btn.dataset.difficulty; startModal.style.display='none'; init(); animate(); spawnEnemies(); }); });

restartBtn.addEventListener('click',()=>{ init(); animate(); spawnEnemies(); gameOverModal.style.display='none'; });
</script>
</body>
</html>
